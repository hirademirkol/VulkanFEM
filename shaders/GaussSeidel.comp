#version 450

#define N_BITS_X 11
#define N_BITS_Y 11
#define N_BITS_Z 10

#define vertexIndex gl_GlobalInvocationID.x

layout(constant_id =  0) const int elementGridSizeX = 0;
layout(constant_id =  1) const int elementGridSizeY = 0;
layout(constant_id =  2) const int elementGridSizeZ = 0;
layout(constant_id =  3) const int vertexGridSizeX = 0;
layout(constant_id =  4) const int vertexGridSizeY = 0;
layout(constant_id =  5) const int vertexGridSizeZ = 0;
layout(constant_id =  6) const int numVertices = 0;
layout(constant_id =  9) const int oneOverDt = 0;

layout(push_constant) uniform constants{
	int color;
};

// The execution structure
//layout (local_size_x = 3, local_size_y = 3, local_size_z = 3) in;

// The buffers are provided via the tensors
layout(binding = 0) buffer elementGridBuffer { int elementGrid[]; };
layout(binding = 1) buffer vertexGridBuffer { int vertexGrid[]; };
layout(binding = 2) buffer vertexFixedBuffer { bool vertexFixedGrid[]; };
layout(binding = 3) buffer positionBuffer { int pos[]; };
layout(binding = 4) buffer energyBuffer { float E[]; };
layout(binding = 5) buffer massBuffer { float mass[]; };
layout(binding = 6) buffer KeBuffer { double Ke[]; };
layout(binding = 7) buffer fBuffer { float f[]; };
layout(binding = 8) buffer uBuffer { float u[]; };

ivec3 UnpackPosition(int i)
{
    ivec3 pos;
	pos.x = i & ((1 << N_BITS_X) - 1);
	pos.y = (i >> N_BITS_X) & ((1 << N_BITS_Y) - 1);
	pos.z = (i >> (N_BITS_X + N_BITS_Y)) & ((1 << N_BITS_Z) - 1);
    
    return pos;
}

int Linearize(ivec3 v, ivec3 size)
{
    return v.x + v.y * size.x + v.z * (size.x * size.y);
}

void main() {
    ivec3 vertexPos = UnpackPosition(pos[vertexIndex]);
    ivec3 elementGridSize = {elementGridSizeX, elementGridSizeY, elementGridSizeZ};
	ivec3 vertexGridSize = {vertexGridSizeX, vertexGridSizeY, vertexGridSizeZ};

    if(!vertexFixedGrid[vertexIndex])
    {
        float E_vert[8];

        #pragma unroll
        for(int i = 0; i < 8; i++)
        {
            int ix = i % 2; int iy = (i % 4) / 2; int iz = i / 4;
            ivec3 elementPosition = { vertexPos.x + (ix - 1), vertexPos.y + (iy - 1), vertexPos.y + (iz - 1) };

			E_vert[i] = 0.0f;

			if (elementPosition.x < 0 || elementPosition.x >= elementGridSize.x) { continue; }
			if (elementPosition.y < 0 || elementPosition.y >= elementGridSize.y) { continue; }
			if (elementPosition.z < 0 || elementPosition.z >= elementGridSize.z) { continue; }

			int elementIndex = elementGrid[Linearize(elementPosition, elementGridSize)];
			
			if (elementIndex == -1) { continue; }
			
			E_vert[i] = E[elementIndex];
        }

		vec3 sum = { f[vertexIndex], f[numVertices + vertexIndex], f[2 * numVertices + vertexIndex]};

		#pragma unroll
		for (int i = 0; i < 27; i++)
		{
			int ix = i % 3; int iy = (i % 9) / 3; int iz = i / 9;
			if (i == 13) { continue; }

			
			mat3 m;
			#pragma unroll
			for (int row = 0; row < 3; row++)
			{
				m[row].x = 0.0f;
				m[row].y = 0.0f;
				m[row].z = 0.0f;
			}

			#pragma unroll
			for (int j = 0; j < 8; j++)
			{
				int jx = j % 2; int jy = (j % 4) / 2; int jz = j / 4;
				int kx = ix - jx; int ky = iy - jy; int kz = iz - jz;
				if (!(0 <= kx && kx < 2 && 0 <= ky && ky < 2 && 0 <= kz && kz < 2)) { continue; }
				
				int k = kx + ky * 2 + kz * 4;

				#pragma unroll
				for (int row = 0; row < 3; row++)
				{
						m[row].x += float(E_vert[j] * Ke[((7 - j) * 3 + row) * 24 + k * 3 + 0]);
						m[row].y += float(E_vert[j] * Ke[((7 - j) * 3 + row) * 24 + k * 3 + 1]);
						m[row].z += float(E_vert[j] * Ke[((7 - j) * 3 + row) * 24 + k * 3 + 2]);
				}
			}

			ivec3 stencilVertexPosition = { vertexPos.x + (ix - 1), vertexPos.y + (iy - 1), vertexPos.z + (iz - 1) };

			if (stencilVertexPosition.x < 0 || stencilVertexPosition.x >= vertexGridSize.x) { continue; }
			if (stencilVertexPosition.y < 0 || stencilVertexPosition.y >= vertexGridSize.y) { continue; }
			if (stencilVertexPosition.z < 0 || stencilVertexPosition.z >= vertexGridSize.z) { continue; }

			int stencilVertexIndex = vertexGrid[Linearize(stencilVertexPosition, vertexGridSize)];

			if (stencilVertexIndex == -1) { continue; }

			if (vertexFixedGrid[stencilVertexIndex]) { continue; }

			// TODO: Is this right?
			vec3 u_vert = { u[stencilVertexIndex], u[numVertices + stencilVertexIndex], u[2 * numVertices + stencilVertexIndex] };

			#pragma unroll
			for (int row = 0; row < 3; row++)
			{
				sum[row] -= m[row].x * u_vert.x + m[row].y * u_vert.y + m[row].z * u_vert.z;
			}
		}

		mat3 m;
		#pragma unroll
		for (int row = 0; row < 3; row++)
		{
			m[row].x = 0.0f;
			m[row].y = 0.0f;
			m[row].z = 0.0f;
		}

		#pragma unroll
		for (int j = 0; j < 8; j++)
		{
			int jx = j % 2; int jy = (j % 4) / 2; int jz = j / 4;
			int kx = 1 - jx; int ky = 1 - jy; int kz = 1 - jz;
			if (!(0 <= kx && kx < 2 && 0 <= ky && ky < 2 && 0 <= kz && kz < 2)) { continue; }
				
			int k = kx + ky * 2 + kz * 4;

			#pragma unroll
			for (int row = 0; row < 3; row++)
			{
				m[row].x += float(E[j] * Ke[((7 - j) * 3 + row) * 24 + k * 3 + 0]);
				m[row].y += float(E[j] * Ke[((7 - j) * 3 + row) * 24 + k * 3 + 1]);
				m[row].z += float(E[j] * Ke[((7 - j) * 3 + row) * 24 + k * 3 + 2]);
			}
		}

		float d = mass[vertexIndex] * oneOverDt * oneOverDt;
		m[0].x += d;
		m[1].y += d;
		m[2].z += d;

		vec3 u_vert;
		u_vert.y = u[numVertices + vertexIndex];
		u_vert.z = u[2 * numVertices + vertexIndex];
		
		sum.x -= m[0].y * u_vert.y + m[0].z * u_vert.z;
		u_vert.x = sum.x / m[0].x;
		sum.y -= m[1].x * u_vert.x + m[1].z * u_vert.z;
		u_vert.y = sum.y / m[1].y;
		sum.z -= m[2].x * u_vert.x + m[2].y * u_vert.y;
		u_vert.z = sum.z / m[2].z;

		u[vertexIndex] = u_vert.x;
		u[numVertices + vertexIndex] = u_vert.y;
		u[2 * numVertices + vertexIndex] = u_vert.z;
    }
    else
	{
		u[vertexIndex] = 0.0f;
		u[numVertices + vertexIndex] = 0.0f;
		u[2 * numVertices + vertexIndex] = 0.0f;
	}
}